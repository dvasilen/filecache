{"name":"filecache.go","tagline":"A simple file cache implementation in Go.","body":"## Overview\r\n\r\nA file cache can be created with either the `NewDefaultCache()` function to\r\nget a cache with the defaults set, or `NewCache()` to get a new cache with\r\n`0` values for everything; you will not be able to store items in this cache\r\nuntil the values are changed; specifically, at a minimum, you should set\r\nthe `MaxItems` field to be > 0.\r\n\r\nLet's start with a basic example; we'll create a basic cache and give it a\r\nmaximum item size of 128M:\r\n\r\n```\r\ncache := filecache.NewDefaultCache()\r\ncache.MaxSize = 128 * filecache.Megabyte\r\ncache.Start()\r\n```\r\n\r\nThe `Kilobyte`, `Megabyte`, and `Gigabyte` constants are provided as a\r\nconvience when setting cache sizes.\r\n\r\nYou can transparently read and cache a file using `ReadFile`  (and\r\n`ReadFileString`); if the file is not in the cache, it will be read\r\nfrom the file system and returned; the cache will start a background\r\nthread to cache the file. Similarly, the `WriterFile` method will write\r\nthe file to the specified `io.Writer`. For example, you could create a\r\n`FileServer` function along the lines of \r\n\r\n```\r\n   func FileServer(w http.ResponseWriter, r *http.Request) {\r\n           path := r.URL.Path\r\n           if len(path) > 1 {\r\n                   path = path[1:len(path)]\r\n           } else {\r\n                   path = \".\"\r\n           }\r\n\r\n           err := cache.WriteFile(w, path)\r\n           if err == nil {\r\n                   ServerError(w, r)\r\n           } else if err == filecache.ItemIsDirectory {\r\n                   DirServer(w, r)\r\n           }\r\n      }\r\n```\r\n\r\nWhen `cache.Start()` is called, a goroutine is launched in the background\r\nthat routinely checks the cache for expired items. The delay between\r\nruns is specified as the number of seconds given by `cache.Every` (\"every\r\n`cache.Every` seconds, check for expired items\"). There are three criteria\r\nused to determine whether an item in the cache should be expired; they are:\r\n\r\n   1. Has the file been modified on disk? (The cache stores the last time\r\n      of modification at the time of caching, and compares that to the\r\n      file's current last modification time).\r\n   2. Has the file been in the cache for longer than the maximum allowed\r\n      time?\r\n   3. Is the cache at capacity? When a file is being cached, a check is\r\n      made to see if the cache is currently filled. If it is, the item that\r\n      was last accessed the longest ago is expired and the new item takes\r\n      its place. When loading items asynchronously, this check might miss\r\n      the fact that the cache will be at capacity; the background scanner\r\n      performs a check after its regular checks to ensure that the cache is\r\n      not at capacity.\r\n\r\nThe background scanner can be disabled by setting `cache.Every` to 0; if so,\r\ncache expiration is only done when the cache is at capacity.\r\n\r\nOnce the cache is no longer needed, a call to `cache.Stop()` will close down\r\nthe channels and signal the background scanner that it should stop.\r\n\r\n\r\n## Usage\r\n\r\n### Initialisation and Startup\r\n\r\nThe public fields of the `FileCache` struct are:\r\n\r\n```\r\n    MaxItems   int   // Maximum number of files to cache\r\n    MaxSize    int64 // Maximum file size to store\r\n    ExpireItem int   // Seconds a file should be cached for\r\n    Every      int   // Run an expiration check Every seconds\r\n```\r\n\r\nYou can create a new file cache with one of two functions:\r\n\r\n* `NewCache()`: creates a new bare repository that just has the underlying\r\ncache structure initialised. The public fields are all set to `0`, which is\r\nvery likely not useful (at a minimum, a `MaxItems` of `0` means no items can\r\nor will be stored in the cache).\r\n* `NewDefaultCache()` returns a new file cache initialised to some basic\r\ndefaults. The defaults are:\r\n\r\n```\r\n\tDefaultExpireItem int   = 300 // 5 minutes\r\n\tDefaultMaxSize    int64 =  4 * Megabyte\r\n\tDefaultMaxItems   int   = 32\r\n\tDefaultEvery      int   = 60 // 1 minute\r\n```\r\n\r\nThese defaults are public variables, and you may change them to more useful\r\nvalues to your program.\r\n\r\nOnce the cache has been initialised, it needs to be started using the\r\n`Start()` method. This is important for initialising the goroutine responsible\r\nfor ensuring the cache remains updated, as well as setting up the asynchronous\r\ncaching goroutine. The `Active` method returns true if the cache is currently\r\nrunning. `Start()` returns an `error` if an error occurs; if one is returned,\r\nthe cache should not be used.\r\n\r\n### Cache Information\r\n\r\nThe `FileCache` struct has several methods to return information about the\r\ncache:\r\n\r\n* `Size()` returns the number of files that are currently in the cache.\r\n* `FileSize()` returns the sum of the file sizes stored in the cache; each \r\nitem on the cache takes up approximately 32 bytes on top of this as overhead.\r\n* `StoredFiles()` returns a list of strings containing the names of the files\r\ncurrently cached. These are not sorted in any way.\r\n* `InCache(name string)` returns true if `name` is in the cache.\r\n\r\n### Primary Methods\r\nWhile the cache has several methods available, there are four main functions\r\nyou will likely use to interact with cache apart from initialisation and\r\nshutdown. All three of them provide transparent access to files; if the file\r\nis in the cache, it is read from the cache. Otherwise, the file is checked\r\nto make sure it is not a directory or uncacheable file, returning an error\r\nif this is the case. Finally, a goroutine is launched to cache the file in\r\nthe background while the file is read and its contents provided directly from\r\nthe filesystem.\r\n\r\n* `RetrieveFile(name string) ([]byte, error)` is used to get the contents of\r\nfile as a byte slice.\r\n* `RetrieveFileString(name string) (string, error)` is used to get the\r\ncontents of a file as a string.\r\n* `WriteFile(w io.Writer, name) error` is used to write the contents of the\r\nfile to the `io.Writer` interface given.\r\n* `HttpWriteFile(w http.ResponseWriter, r *http.Request)` will write the\r\ncontents of the file transparently over an HTTP connect. This should be\r\nused when the writer is an HTTP connection and will handle the\r\nappropriate HTTP headers.\r\n\r\nIf you are using the file cache in an HTTP server, you might find the\r\nfollowing function useful:\r\n\r\n* `HttpHandler(*FileCache) func(w http.ResponseWriter, r *http.Request)`\r\nreturns a function that can then be used directly in `http.HandleFunc`\r\ncalls.\r\n\r\nMost people can now skip to the *Shutting Down* section.\r\n\r\n### Reading from the Cache\r\n\r\nIf you are certain a file has been cached, and you want to access it directly\r\nfrom the cache, you can use these functions:\r\n\r\n* `GetItem(name string) ([]byte, bool)` will retrieve a byte slice containing\r\nthe contents of the file and a boolean indiciating whether the file was in\r\nthe cache. If it is not in the cache, the byte slice will be empty and no\r\nattempt is made to add the file to the cache.\r\n* `GetItemString(name string) (string, bool)` is the same as `GetItem` except\r\nthat it returns a string in place of the byte slice.\r\n* `WriteItem(w io.Writer, name string) (err error)` is the same as `WriteFile`\r\nexcept that no attempt is made to add the file to cache if it is not present.\r\n\r\n### Add to the Cache\r\n\r\nYou can cache files without reading them using the two caching functions:\r\n\r\n* `Cache(name string)` will cache the file in the background. It returns\r\nimmediately and errors are not reported; you can determine if the item is\r\nin the cache with the `InCache` method; note that as this is a background\r\ncache, the file may not immediately be cached.\r\n* `CacheNow(name string) error` will immediately cache the file and block\r\nuntil it has been cached, or until an error is returned.\r\n\r\n### Removing from the Cache\r\n\r\nThe `Remove(name string) (bool, error)` method will remove the file named\r\nfrom the cache. If the file was not in the cache or could not be removed,\r\nit returns false.\r\n\r\n### Shutting Down\r\n\r\nOnce you are done with the cache, the `Stop` method takes care of all the\r\nnecessary cleanup.\r\n\r\n## License\r\n\r\n`filecache` is released under the ISC license:\r\n\r\n```\r\nCopyright (c) 2012 Kyle Isom <kyle@tyrfingr.is>\r\n\r\nPermission to use, copy, modify, and distribute this software for any\r\npurpose with or without fee is hereby granted, provided that the above \r\ncopyright notice and this permission notice appear in all copies.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\r\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\r\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\r\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\r\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\r\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\r\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. \r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}